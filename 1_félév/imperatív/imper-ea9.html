<html>
  
  <head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Homepage of Dr. Zoltán Porkoláb</title>
  <meta name="description" content="Dr. Zoltán Porkoláb is an Associate Professor of the Department of Programming Languages and Compilers at the Faculty of Informatics, Eötvös Loránd University (ELTE), Budapest, Hungary.  At the same time, he holds Principal C++ Developer position at Ericsson Hungary Ltd.">

  <link rel="stylesheet" href="css/default.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="canonical" href="http://gsd.web.elte.hu/lectures/imper/imper-lecture-9/">
  <link rel="alternate" type="application/rss+xml" title="Homepage of Dr. Zoltán Porkoláb" href="http://gsd.web.elte.hu/feed.xml" />
</head>


  <body>
    <div id='wrap'>

      <!--<div id='header'>
  <div class='tagline'>Homepage of Dr. Zoltán Porkoláb</div>
</div>
-->

      <div id='pages'>
  <ol class='toc'>
    <li>Homepage of Dr. Zoltán Porkoláb
      <ol class="toc"> 
        <li><a href='/'>Home</a></li>
        <li><a href='/archive'>Archive</a></li>
      </ol>
    <li>Teaching
      <ol class="toc">
        <li><a href='/timetable'>Timetable</a></li>
        <li><a href='/imper'>Imperative programming (BSc)</a></li>
        <li><a href='/multi'>Multiparadigm programming (MSc)</a></li>
        <li><a href='/c-phys'>C programming (BSc for physicists)</a></li>
        <li><a href='/tools'>Project tools (BSc)</a></li>
        <li><a href='/bolyai'>Bolyai College</a></li>
        <li><a href='/cpp-en'>C++ (for foreign studenst)</a></li>
        <li><a href='/softtech'>Software technology lab</a></li>
        <li><a href='/thesis'>BSc and MSc thesis</a></li>
      </ol>
    </li>
    <li>Research
      <ol class="toc">
        <li><a href='http://plc.inf.elte.hu/templight'>Templight</a></li>
        <li><a href='https://github.com/Ericsson/codechecker'>CodeChecker</a></li>
        <li><a href='https://github.com/Ericsson/codecompass'>CodeCompass</a></li>
        <li><a href='/projects'>Projects</a></li>
        <li><a href='http://aszt.inf.elte.hu/~gsd/porkolab_publications_en_2011.pdf'>Publications (up to 2011)</a></li>
        <li><a href='http://www.doktori.hu/index.php?menuid=192&sz_ID=2806&lang=EN'>PhD students</a></li>
      </ol>
    </li>
    <li>Affiliations
      <ol class="toc">
        <li><a href='http://plcportal.inf.elte.hu/'>Dept. of Programming Languages and Compilers</a></li>
        <li><a href='http://www.ericsson.com/hu'>Ericsson Hungary Ltd</a></li>
      </ol>
    </li>
  </ol>
</div>


      <div id='content'>
        <h1 id=''></h1>
        <div class="post">

  <!--header class="post-header">
    <h1 class="post-title"></h1>
    <p class="post-meta"></p>
  </header-->

  <article class="post-content">
    <div class="post">

  <!--header class="post-header">
    <h1 class="post-title"></h1>
  </header-->

  <article class="post-content">
    <h1 id="imperatv-programozs-9">Imperatív programozás 9.</h1>

<h1 id="sszetett-adatszerkezetek">Összetett adatszerkezetek</h1>

<p>A programozási nyelvekben gyakan van szükség összetett adatok kezelésére. 
Ezek közé tartozik a <strong>tömb</strong> (<a href="/lectures/imper/imper-lecture-8/">tömbök</a>), 
ami azonos típusú elemek (egy- vagy többdimenziós) véges sorozatából áll, 
a <strong>rekord</strong>, ami különböző típusok rendezett N-ese, az <strong>únió</strong>, ami egy 
időben véges számú típus közül pontosan egyet tudj tárolni. Bár nem összetett 
adattípus, de itt tárgyaljuk a <strong>felsorolási típust</strong> is. Egyes imperatív 
nyelvekben további összetett típusok is létezhetnek, mint pl. a <strong>halmaz</strong> 
(set) típus Pascal-ban.</p>

<p>Az összetett típusok maguk is tartalmazhatnak beépített vagy összetett 
típusokat, így alkothatunk rekordokból vagy úniókból tömböket, rekordok és
úniók tartalmazhatnak tömböket, rekordokat, úniókat, felsorolási értékeket.</p>

<h2 id="rekord-tpus">Rekord típus</h2>

<p>Programjainkban gyakran kell többféle adatot együtt kezelnünk: pl. egy dolgozó 
aznosítóját, nevét, beosztását, születési dátumát; egy előadás kódját,
oktatóját, a hozzás tartozó gyakorlatok adatait (amik maguk is lehetnek 
összetett adatok). Ilyenkor kényelmes lenne, ha ezeket az adatokat egyetlen
változóban tárolhatnánk, paraméterként átadhatnánk, egyetlen utasítással 
adhatnánk értéket. Ezt a fajta adatszerkezetet nevezzük <strong>rekord</strong>-nak, 
(record) vagy <strong>struktúrának</strong> (struct). Az <em>R = (R1, R2, …, Rn)</em> rekord
a <em>T1</em>, <em>T2</em>, … <em>Tn</em> típusok direkt szorzata <em>R = T1 x T2 x … x Tn</em>.</p>

<p>A rekord típus összetevőit <strong>tag</strong>-nak (member) vagy <strong>mező</strong>-nek (field) 
nevezzük, minden tag egy névvel és típussal rendelkezik, és ez utóbbinak 
megfelelő műveleteket lehet elvégezni rajta. A rekord típus leggyakoribb 
implementációja, hogy az egyes tagok egymás után helyezkednek el a memóriában. 
Minden tag a rekord elejéhez képest saját távolsággal (offset) rendelkezik. 
Esetenként azonban a tagok között lehetnek “lyukak” (gap) is, itt nem 
tárolunk információt. Lyukak amiatt lehetnek, mert egyes fordítók bizonyos 
típusokat csak adott bájtcímekre helyezhetnek el. Ebből következően a 
rekord mérete nagyobb vagy egyenlő a mezők méreteinek összegével.</p>

<p>A rekord típussal rendszerint csak a legegyszerűbb műveleteket végezhetjük
el, pl. <strong>értékadás</strong>, ide értve az érték szerinti paraméterátadást és 
függvényvisszatérést is, a rekord <strong>címének</strong> lekérdezése, és az egyes 
<strong>tagok</strong> (mezők) <strong>elérése</strong>. Miután a rekord egy mezőjét elértük, az adott 
mező típusának megfelelő műveleteket végezhetünk rajta.</p>

<p>Előfordul, hogy a rekord bizonyos része többféleképpen is lehet definiálva.
Az ilyen <strong>variadic record</strong>-okat lentebb, az úniónál tárgyaljuk.</p>

<p>Az <strong>objektum-orientált</strong> nyelvekben az <strong>osztályt</strong> (class) tekinthetjük a 
rekordtípus olyan általánosításának, ahol az adattagok mellett a rajtuk
végzett műveleteket (tagfüggvényeket) is definiálhatjuk, illetve megadhatjuk
az egyes tagok hozzáférési jogait (public, private, …).</p>

<h2 id="struct-c-ben">Struct C-ben</h2>

<p>A C programozási nyelvben a rekord (struktúra) típust a <strong>struct</strong> konstrukció 
valósítja meg. A <strong>struct</strong> kulcsszó része a struktúra típusnevének, azaz a 
változó deklarációjából nem hagyhatjuk el. A következő példában egy dátum 
<em>int</em> számhármassal történő lehetséges megvalósítása szerepel:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="k">struct</span> <span class="n">date</span>
<span class="lineno"> 2</span> <span class="p">{</span>
<span class="lineno"> 3</span>   <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
<span class="lineno"> 4</span>   <span class="kt">int</span> <span class="n">month</span><span class="p">;</span>
<span class="lineno"> 5</span>   <span class="kt">int</span> <span class="n">day</span><span class="p">;</span>   
<span class="lineno"> 6</span> <span class="p">};</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="lineno"> 9</span> <span class="p">{</span>
<span class="lineno">10</span>   <span class="k">struct</span> <span class="n">date</span> <span class="n">exam</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2018</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">17</span><span class="p">};</span> <span class="cm">/* mezőnkénti inicializálás  */</span>
<span class="lineno">11</span>   <span class="k">struct</span> <span class="n">date</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">exam</span><span class="p">;</span>            <span class="cm">/* ep a vizsgára mutat       */</span> 
<span class="lineno">12</span>   <span class="o">++</span><span class="n">exam</span><span class="p">.</span><span class="n">day</span><span class="p">;</span>               <span class="cm">/* egy nappal elhalasztva              */</span>
<span class="lineno">13</span>   <span class="p">(</span><span class="o">*</span><span class="n">ep</span><span class="p">).</span><span class="n">day</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>           <span class="cm">/* még két nap halasztás               */</span>
<span class="lineno">14</span>   <span class="n">ep</span><span class="o">-&gt;</span><span class="n">day</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>             <span class="cm">/* ep-&gt;day ugyanaz, mint az (*ep).day  */</span>
<span class="lineno">15</span>   <span class="n">assert</span><span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">year</span><span class="p">);</span>  <span class="cm">/* struct címe azonos első tag címével */</span>
<span class="lineno">16</span> 
<span class="lineno">17</span>   <span class="k">struct</span> <span class="n">date</span> <span class="n">y2019</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2019</span><span class="p">};</span>   <span class="cm">/* csak a year mezőt inicializálja */</span>
<span class="lineno">18</span>   <span class="k">struct</span> <span class="n">date</span> <span class="n">xmas</span>  <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">month</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="p">.</span><span class="n">day</span> <span class="o">=</span> <span class="mi">24</span> <span class="p">};</span>  <span class="cm">/* csak C99 óta */</span> 
<span class="lineno">19</span> <span class="p">}</span></code></pre></div>

<p>A tagok elérését a <strong>pont</strong> (dot, member access) operátor teszi lehetővé. 
A struktúra típusú változó címét a szokásos <strong>címoperátorral</strong> (&amp;) kérhetjük
le, ennek a C-ben azonosnak kell lennie az első adattag (itt a year) címével.
Mivel nagyon gyakori, hogy egy struktúrát a rá mutató pointeren keresztül 
érünk el, a <strong>(*ptr).field</strong> kifejezés helyett használhatjuk a rövidebb
<strong>ptr-&gt;field</strong> jelölést. A struktúrát a tömböknél megszokott listával
 <strong>{ … }</strong>  inicializálhatjuk, illetve C99-től használhatunk inicializálást 
csak egyes mezőkre is.</p>

<p>Fontos megérteni, hogy a fenti példában az 1-6 sorok egy struktúra típust 
definiálnak. Ez nem egy változó, nem konkrét adatterület, nem lehet bele írni.
Ez csak a dátum típus leírása, hogyan kell értelmezni a <em>date</em>  összetett 
adatszerkezetet. Értékeket csak változókba írhatunk, azt létre kell hoznunk,
pl. a 10. sorban található definicióval.</p>

<p>A következő példában egy alakzat típust definiálunk.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="k">struct</span> <span class="n">square</span> 
<span class="lineno"> 2</span> <span class="p">{</span> 
<span class="lineno"> 3</span>   <span class="kt">int</span> <span class="n">centerX</span><span class="p">;</span> 
<span class="lineno"> 4</span>   <span class="kt">int</span> <span class="n">centerY</span><span class="p">;</span> 
<span class="lineno"> 5</span>   <span class="kt">int</span> <span class="n">side</span><span class="p">;</span> 
<span class="lineno"> 6</span> <span class="p">};</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> <span class="k">struct</span> <span class="n">square</span> <span class="nf">move</span><span class="p">(</span> <span class="k">struct</span> <span class="n">square</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">deltaX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">deltaY</span><span class="p">);</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="lineno">11</span> <span class="p">{</span>
<span class="lineno">12</span>   <span class="k">struct</span> <span class="n">square</span> <span class="n">mySquare</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>   <span class="cm">/* inicializáció */</span>
<span class="lineno">13</span> 
<span class="lineno">14</span>   <span class="n">mySquare</span><span class="p">.</span><span class="n">centerX</span> <span class="o">+=</span> <span class="mi">20</span><span class="p">;</span>    <span class="cm">/* mozgassuk el mySquare-t */</span> 
<span class="lineno">15</span>   <span class="n">mySquare</span><span class="p">.</span><span class="n">centerY</span> <span class="o">+=</span> <span class="mi">30</span><span class="p">;</span>    <span class="cm">/* a (+20,+30) vektorral   */</span> 
<span class="lineno">16</span> 
<span class="lineno">17</span>   <span class="n">mySquare</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">mySquare</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>  <span class="cm">/* függvénnyel */</span>
<span class="lineno">18</span> <span class="p">}</span></code></pre></div>

<p>Egy C struct változóit <strong>értékül adhatjuk</strong> hasonló típusú változóknak, 
ilyenkor az összes adattag <strong>átmásolódik</strong>. Ahogy a fenti példa mutatja, 
struct-okat átadhatunk paraméterként függvényeknek, és azok vissza is adhatnak 
struct-okat.Ilyenkor az érték szerinti paraméterátadás szerint a teljes struct 
másolódik (ellentétben a tömbökkel, ahol az első elemre mutató pointer adódik 
át). Ha sok adattagból álló nagyméretű struct-ot használunk, néha hatékonysági 
okokból a címűket adjuk át paraméterként. Struktúrákra a <strong>relációs 
műveletek</strong>, mint pl. az <strong>==</strong> és <strong>!=</strong> <strong>nem értelmezett</strong>.</p>

<p>Struktúrák tartalmazhatnak további struktúrákat. Egy <em>személy</em> például
rendelkezik születési dátummal:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="k">struct</span> <span class="n">person</span>
<span class="lineno"> 2</span> <span class="p">{</span>
<span class="lineno"> 3</span>   <span class="kt">char</span>         <span class="n">name</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>
<span class="lineno"> 4</span>   <span class="k">struct</span> <span class="n">date</span>  <span class="n">birthday</span><span class="p">;</span>
<span class="lineno"> 5</span> <span class="p">};</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="kt">int</span> <span class="nf">ask</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="lineno"> 8</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="lineno"> 9</span> <span class="p">{</span>
<span class="lineno">10</span>   <span class="k">struct</span> <span class="n">person</span> <span class="n">dean</span><span class="p">;</span>
<span class="lineno">11</span>   <span class="n">strncpy</span><span class="p">(</span> <span class="n">dean</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Horvath Zoltan&quot;</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
<span class="lineno">12</span>   <span class="n">dean</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="mi">39</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="lineno">13</span>   <span class="n">dean</span><span class="p">.</span><span class="n">birthday</span><span class="p">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">ask</span><span class="p">();</span>
<span class="lineno">14</span> <span class="p">}</span></code></pre></div>

<p>Mivel a pont operátor <em>balról asszociatív</em> (<a href="/lectures/imper/imper-lecture-4/">operátorok</a>), ezért a dátum adattagjai eléréséhez nem kell zárójelezni.</p>

<p>Előfordul, hogy önhivatkozó adatszerkezeteket szeretnénk létrehozni. Egy 
<em>személynek</em> pl. lehetnek <em>szülei</em> és <em>gyermekei</em> is, akik szintén emberek.
Ilyenkor a <em>személy</em> struktúra fizikailag nem tartalmazhatja önnmagát, de
a logikai kapcsolatokat kifejezhetjük pointerekkel.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno">1</span> <span class="k">struct</span> <span class="n">person</span>
<span class="lineno">2</span> <span class="p">{</span> 
<span class="lineno">3</span>   <span class="kt">char</span>           <span class="n">name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> 
<span class="lineno">4</span>   <span class="k">struct</span> <span class="n">date</span>    <span class="n">birthday</span><span class="p">;</span>
<span class="lineno">5</span>   <span class="k">struct</span> <span class="n">person</span> <span class="o">*</span><span class="n">father</span><span class="p">;</span>
<span class="lineno">6</span>   <span class="k">struct</span> <span class="n">person</span> <span class="o">*</span><span class="n">mother</span><span class="p">;</span>
<span class="lineno">7</span>   <span class="k">struct</span> <span class="n">person</span> <span class="o">*</span><span class="n">children</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="lineno">8</span> <span class="p">};</span></code></pre></div>

<p>Még az a helyzet is előfordulhat, hogy két struktúra kölcsönösen egymásra 
hivatkozik. Mivel a C fordító feltételezi, hogy egy típus definíciójában a
meghivatkozott nevek már definiáltak, a hivatkozási kört egy <strong>előzetes
deklarációval</strong> (forard declaration) tudjuk feloldani:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="k">struct</span> <span class="n">manager</span><span class="p">;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="k">struct</span> <span class="n">staffmember</span>
<span class="lineno"> 4</span> <span class="p">{</span>
<span class="lineno"> 5</span>   <span class="k">struct</span> <span class="n">person</span>   <span class="n">pers</span><span class="p">;</span>
<span class="lineno"> 6</span>   <span class="k">struct</span> <span class="n">manager</span> <span class="o">*</span><span class="n">boss</span><span class="p">;</span>
<span class="lineno"> 7</span> <span class="p">};</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span> <span class="k">struct</span> <span class="n">manager</span>
<span class="lineno">10</span> <span class="p">{</span> 
<span class="lineno">11</span>   <span class="k">struct</span> <span class="n">person</span>       <span class="n">pers</span><span class="p">;</span>
<span class="lineno">12</span>   <span class="k">struct</span> <span class="n">manager</span>     <span class="o">*</span><span class="n">boss</span><span class="p">;</span>
<span class="lineno">13</span>   <span class="k">struct</span> <span class="n">staffmember</span> <span class="o">*</span><span class="n">staff</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="lineno">14</span> <span class="p">};</span></code></pre></div>

<p>A legmagasabb pozícióban dolgozó főnök <em>boss</em> pointere NULL lesz.</p>

<h2 id="felsorolsi-tpus-c-ben">Felsorolási típus C-ben</h2>

<p>A C felsorolási típus valójában egy egész értékekből álló halmaz, aminek 
értékeit szimbolikus nevekkel jelölhetjük.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="k">enum</span> <span class="n">color</span> <span class="p">{</span> <span class="n">WHITE</span><span class="p">,</span> <span class="n">GREEN</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">YELLOW</span><span class="p">,</span> <span class="n">RED</span><span class="p">,</span> <span class="n">BLACK</span><span class="p">};</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="lineno"> 4</span> <span class="p">{</span>
<span class="lineno"> 5</span>   <span class="k">enum</span> <span class="n">color</span> <span class="n">traffic_light</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
<span class="lineno"> 6</span>   <span class="k">enum</span> <span class="n">color</span> <span class="o">*</span><span class="n">cptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">traffic_light</span><span class="p">;</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span>   <span class="k">switch</span><span class="p">(</span> <span class="o">*</span><span class="n">cptr</span> <span class="p">)</span>
<span class="lineno"> 9</span>   <span class="p">{</span>
<span class="lineno">10</span>   <span class="k">case</span> <span class="nl">RED</span><span class="p">:</span>    <span class="n">puts</span><span class="p">(</span><span class="s">&quot;stop!&quot;</span><span class="p">);</span>  <span class="k">break</span><span class="p">;</span>
<span class="lineno">11</span>   <span class="k">case</span> <span class="nl">YELLOW</span><span class="p">:</span> <span class="n">puts</span><span class="p">(</span><span class="s">&quot;break!&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span> 
<span class="lineno">12</span>   <span class="k">default</span><span class="o">:</span>     <span class="n">puts</span><span class="p">(</span><span class="s">&quot;go!&quot;</span><span class="p">);</span>    <span class="k">break</span><span class="p">;</span>
<span class="lineno">13</span>   <span class="p">}</span>
<span class="lineno">14</span>   <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">cptr</span> <span class="o">&lt;</span> <span class="n">YELLOW</span> <span class="p">)</span>   <span class="n">puts</span><span class="p">(</span><span class="s">&quot;go!&quot;</span><span class="p">);</span>
<span class="lineno">15</span>   <span class="o">*</span><span class="n">cptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>                    
<span class="lineno">16</span>   <span class="n">assert</span> <span class="p">(</span> <span class="o">*</span><span class="n">cptr</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="p">);</span>
<span class="lineno">17</span> <span class="p">}</span></code></pre></div>

<p>A felsorolási típus értékei a { } közötti felsorolásból kerülnek ki. Ha a
felsorolóban egy névnél szerepel a <strong>=</strong> jel, akkor az a felsoroló azt az 
értéket veszi fel. Ha ilyen nem szerepel, akkor az előző felsorolónál egyel
nagyobb lesz. Az első felsoroló értéke, ha explicit mást nem rendelünk hozzá
a nulla lesz. Az értékeknek egyedieknek kell lennie, ezt a fordító ellenőrzi.</p>

<p>A felsolási értékek valamely egész típusra képződnek le, mint a <strong>char</strong> 
<strong>signed</strong> vagy <strong>unsigned</strong> <strong>int</strong>. Ennek megfelelően a felsorolási értékek
úgy viselkednek, mint az egészek, rézst vesznek konverziókban és alkalmazhatóak
rájuk az aritmetikai operátorok is.</p>

<h2 id="ni-tpus">Únió típus</h2>

<p>Egy másik összetett adatszerkezet, az <strong>únió</strong> (union), ami a halmazok 
úniójához hasonló konstrukció. Az <em>U = (U1, U2, …, Un) únió, a _T1, T2,
…, Tn típuok úniója _U = T1 u T2 u … u Tn</em>. Amíg a rekordban a tagokat 
egy időben egyszerre, egymás után tároljuk, addig az únióban csak egyetlen 
típust tárolhatunk egy időben, de később ezt felülírhatjuk egy másik típussal.
Ebből következően az únió mérete legalább akkora, mint a legnagyobb komponense
(néha technikai okokból annál hosszabb).</p>

<p>Az únió tagjait úgy is tekinthetjük, mint típusbiztos interfészt, amelyen 
keresztül beírhatunk és kiolvashatunk az únióba. Amennyiben nem a megfelelő
tagot használjuk kiolvasáshoz, akkor az eredmény hibás lehet.</p>

<p><strong>Statikus típusrendszer</strong> esetén azt, hogy mi volt a legutolsó értékadás 
típusa, vagy a programozó kell számontartsa, vagy tudhatja maga az únió típusú 
változó. Ez utóbbi esetben ún. <strong>címkézett únió</strong>-ról (tagged union) vagy 
<strong>variáns</strong> (variant record) típusról beszélünk. Ilyen tagged union létezik 
számos funkcionális és imperatív nyelvben, pl. a <em>Pascal</em>-ban, <em>Modula-2</em>-ben, 
az <em>Ada</em>-ban, a <em>Scala</em>-ban, <em>Rust</em>-ban. A <em>C++</em>-ban a C++17-es szabványtól 
az std::variant típus valósítja meg.</p>

<div class="highlight"><pre><code class="language-pascal" data-lang="pascal"><span class="lineno"> 1</span> <span class="cm">(* Pascal variant record *)</span>
<span class="lineno"> 2</span> <span class="k">type</span> <span class="n">shapeKind</span> <span class="o">=</span> <span class="p">(</span><span class="n">square</span><span class="o">,</span> <span class="n">rectangle</span><span class="o">,</span> <span class="n">circle</span><span class="p">)</span><span class="o">;</span>
<span class="lineno"> 3</span>  <span class="n">shape</span> <span class="o">=</span> <span class="k">record</span>
<span class="lineno"> 4</span>     <span class="n">centerx</span> <span class="o">:</span> <span class="kt">integer</span><span class="o">;</span>
<span class="lineno"> 5</span>     <span class="n">centery</span> <span class="o">:</span> <span class="kt">integer</span><span class="o">;</span>
<span class="lineno"> 6</span>     <span class="k">case</span> <span class="n">kind</span> <span class="o">:</span> <span class="n">shapeKind</span> <span class="k">of</span>
<span class="lineno"> 7</span>       <span class="n">square</span> <span class="o">:</span> <span class="p">(</span><span class="n">side</span> <span class="o">:</span> <span class="kt">integer</span><span class="p">)</span><span class="o">;</span>
<span class="lineno"> 8</span>       <span class="n">rectangle</span> <span class="o">:</span> <span class="p">(</span><span class="n">lenA</span><span class="o">,</span> <span class="n">lenB</span> <span class="o">:</span> <span class="kt">integer</span><span class="p">)</span><span class="o">;</span>
<span class="lineno"> 9</span>       <span class="n">circle</span> <span class="o">:</span> <span class="p">(</span><span class="n">radius</span> <span class="o">:</span> <span class="kt">integer</span><span class="p">)</span>
<span class="lineno">10</span> <span class="k">end</span><span class="o">;</span></code></pre></div>

<div class="highlight"><pre><code class="language-ada" data-lang="ada"><span class="lineno"> 1</span> <span class="c1">-- Ada variant record (discriminated type) </span>
<span class="lineno"> 2</span> <span class="kd">type</span> <span class="kt">Shape_Kind</span> <span class="kr">is</span> <span class="p">(</span><span class="nv">Square</span><span class="p">,</span> <span class="nv">Rectangle</span><span class="p">,</span> <span class="nv">Circle</span><span class="p">);</span>
<span class="lineno"> 3</span> <span class="kd">type</span> <span class="kt">Shape</span> <span class="p">(</span><span class="nv">Kind</span> <span class="p">: </span><span class="nv">Shape_Kind</span><span class="p">)</span> <span class="kr">is</span> <span class="kr">record</span>
<span class="lineno"> 4</span>    <span class="n">Center_X</span> <span class="p">:</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="lineno"> 5</span>    <span class="n">Center_Y</span> <span class="p">:</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="lineno"> 6</span>    <span class="kr">case</span> <span class="n">Kind</span> <span class="kr">is</span>
<span class="lineno"> 7</span>       <span class="kr">when</span> <span class="n">Square</span> <span class="p">=&gt;</span>
<span class="lineno"> 8</span>          <span class="n">Side</span> <span class="p">:</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="lineno"> 9</span>       <span class="kr">when</span> <span class="n">Rectangle</span> <span class="p">=&gt;</span>
<span class="lineno">10</span>          <span class="n">LenA</span><span class="p">,</span> <span class="n">LenB</span> <span class="p">:</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="lineno">11</span>       <span class="kr">when</span> <span class="n">Circle</span> <span class="p">=&gt;</span>
<span class="lineno">12</span>          <span class="n">Radius</span> <span class="p">:</span> <span class="kt">Integer</span><span class="p">;</span>
<span class="lineno">13</span>    <span class="kr">end</span> <span class="kr">case</span><span class="p">;</span>
<span class="lineno">14</span> <span class="kr">end record</span><span class="p">;</span></code></pre></div>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno">1</span> <span class="c1">// C++ variant típus C++17-től, korábban használható a boost::variant</span>
<span class="lineno">2</span> <span class="k">class</span> <span class="nc">Square</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="lineno">3</span> <span class="k">class</span> <span class="nc">Rectangle</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="lineno">4</span> <span class="k">class</span> <span class="nc">Circle</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="lineno">5</span> 
<span class="lineno">6</span> <span class="n">use</span> <span class="n">Shape</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Square</span><span class="p">,</span> <span class="n">Rectangle</span><span class="p">,</span> <span class="n">Circle</span><span class="o">&gt;</span><span class="p">;</span></code></pre></div>

<p>Az <strong>objektum-orientált</strong> nyelvekben a tagged union-t gyakran <em>örökléssel</em> 
valósítjuk meg: az únió egy interfész vagy ha vannak közös adatok, akkor 
egy bázisosztály és ez egyes “variánsok” pedig a származtatott típusban 
valósíthatóak meg.</p>

<p>A <strong>dinamikus típusrendszerű</strong> nyelvekben nincsen szükség variant-ra, 
hiszen maguk az objektumok “ismerik” saját típusukat. Pythonban például
írhatunk ilyet:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="lineno">1</span> <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="lineno">2</span>     <span class="k">return</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="s">&quot;s&quot;</span></code></pre></div>

<p>Ugyanakkor a Python 3.5 által bevezetett <em>type hint</em>-ek segítségével
az únió használatot explicitté lehet tenni, ami sokat segíthet külső 
eszközök, pl. szintaxis ellenőrzők vagy editorok használatakor.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="lineno">1</span> <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span><span class="n">TypeVar</span>
<span class="lineno">2</span> 
<span class="lineno">3</span> <span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
<span class="lineno">4</span> <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="lineno">5</span>     <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
<span class="lineno">6</span>         <span class="k">return</span> <span class="mi">2</span>
<span class="lineno">7</span>     <span class="k">else</span><span class="p">:</span>
<span class="lineno">8</span>         <span class="k">return</span> <span class="s">&quot;s&quot;</span></code></pre></div>

<h2 id="uni-c-ben">Unió C-ben</h2>

<p>A C-ben az únió típust a <strong>union</strong> kulcsszóval hozzuk létre. Akárcsak a 
struct-nál, a union kulcsszó is része a típus nevének. A union-t képzelhetjük
egy olyan struct-nak, ahol az összes adattag az únió kezdőcímén kezdődik, 
így atagok lényegében “átfedik” egymást.</p>

<p>A C nyelv nem rendelkezik tagged union típussal, az úniók tartalmának 
éppen aktuális típusát a programozónak kell számon tartania. Ezt gyakran 
úgy valósítjuk meg, hogy együttesen használjuk a <strong>struct</strong> és <strong>union</strong>
konstrukciókat és esetleg a felsorolási típust is:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="k">struct</span> <span class="n">square</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">centerX</span><span class="p">;</span> <span class="kt">int</span> <span class="n">centerY</span><span class="p">;</span> <span class="kt">int</span> <span class="n">side</span><span class="p">;</span> <span class="p">};</span>
<span class="lineno"> 2</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">centerX</span><span class="p">;</span> <span class="kt">int</span> <span class="n">centerY</span><span class="p">;</span> <span class="kt">int</span> <span class="n">lenA</span><span class="p">;</span> <span class="kt">int</span> <span class="n">lenB</span><span class="p">;</span> <span class="p">};</span>
<span class="lineno"> 3</span> <span class="k">struct</span> <span class="n">circle</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">centerX</span><span class="p">;</span> <span class="kt">int</span> <span class="n">centerY</span><span class="p">;</span> <span class="kt">int</span> <span class="n">radius</span><span class="p">;</span> <span class="p">};</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> <span class="k">enum</span> <span class="kt">shape_tag_t</span> <span class="p">{</span> <span class="n">square_tag</span><span class="p">,</span> <span class="n">rectangle_tag</span><span class="p">,</span> <span class="n">circle_tag</span> <span class="p">};</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="k">struct</span> <span class="n">shape</span>
<span class="lineno"> 8</span> <span class="p">{</span>
<span class="lineno"> 9</span>   <span class="k">enum</span> <span class="kt">shape_tag_t</span> <span class="n">tag</span><span class="p">;</span>
<span class="lineno">10</span>   <span class="k">union</span> <span class="n">shapeKind</span>
<span class="lineno">11</span>   <span class="p">{</span>
<span class="lineno">12</span>     <span class="k">struct</span> <span class="n">square</span>    <span class="n">s</span><span class="p">;</span>
<span class="lineno">13</span>     <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">r</span><span class="p">;</span>
<span class="lineno">14</span>     <span class="k">struct</span> <span class="n">circle</span>    <span class="n">c</span><span class="p">;</span>
<span class="lineno">15</span>   <span class="p">}</span>   <span class="n">u</span><span class="p">;</span>
<span class="lineno">16</span> <span class="p">};</span>
<span class="lineno">17</span> 
<span class="lineno">18</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="lineno">19</span> <span class="p">{</span>
<span class="lineno">20</span>   <span class="k">struct</span> <span class="n">circle</span> <span class="n">cir</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span> <span class="p">};</span>
<span class="lineno">21</span>   
<span class="lineno">22</span>   <span class="k">struct</span> <span class="n">shape</span>  <span class="n">s</span><span class="p">;</span> 
<span class="lineno">23</span>   <span class="n">s</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">circle_tag</span><span class="p">;</span>
<span class="lineno">24</span>   <span class="n">s</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">cir</span><span class="p">;</span>
<span class="lineno">25</span> 
<span class="lineno">26</span>   <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">centerX</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">centerY</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">radius</span><span class="p">);</span>
<span class="lineno">27</span> <span class="p">}</span></code></pre></div>

<p>Látszik, hogy a shapeKind únió nevet sehol sem használjuk a programban. 
Valójában el is hagyhatjuk, így egy név nélküli (anonym) úniót hozunk
létre <strong>u</strong> tagnévvel. Mivel az <em>s</em>, <em>r</em> és <em>c</em> tagnevek csak az <em>u</em> union
tagban fordulnak elő, ezért használatukkor az <em>u</em> el is hagyható:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="lineno"> 2</span> <span class="p">{</span>
<span class="lineno"> 3</span>   <span class="k">struct</span> <span class="n">circle</span> <span class="n">cir</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span> <span class="p">};</span>
<span class="lineno"> 4</span>   
<span class="lineno"> 5</span>   <span class="k">struct</span> <span class="n">shape</span>  <span class="n">s</span><span class="p">;</span> 
<span class="lineno"> 6</span>   <span class="n">s</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">circle_tag</span><span class="p">;</span>
<span class="lineno"> 7</span>   <span class="n">s</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">cir</span><span class="p">;</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span>   <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">centerX</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">centerY</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">radius</span><span class="p">);</span>
<span class="lineno">10</span> <span class="p">}</span></code></pre></div>

<p>Ahogy korábban volt róla szó, a tag-ek lényegében “típusbiztos kapuk”, 
amelyen keresztül elérjük az únióban eltárolt valamely értéket. Ha nem 
az a tagot használjuk olvasásra, amin keresztül legutóbb írtunk az 
únió értékét, hibát kaphatunk. Néha mégis szándékosan csinálunk ilyet, 
pl. ha egy tpus értékét a bitek megváltoztatása nélkül egy másik típusban 
akarunk tárolni. Ilyen eset lehet, pl. ha egy bináris adatot akarunk 
hálózaton átküldeni, és az únió egyik tagja egy kellően hosszú karaktertömb,
amit a hálózati függvény fog továbbítani.</p>

<p><strong>Vigyázat!</strong>, ez nem egy klasszikus értelemben vett típuskonverzió, hiszen
a bitek értéke nem változik meg. Ha pl. egy double és int adattagú únióba
beírunk egy double számot és egészként olvassuk ki, akkor a lebegőpontos
ábrázolás első pár bájtját próbálnánk (valószínűleg értelmetlen) egész 
számként értelmezni.</p>

<h1 id="dinamikus-memriakezels">Dinamikus memóriakezelés</h1>

<p>A C programok statikus, automatikus és dinamikus élettartamú tárterületeket
hozhatnak létre (<a href="/lectures/imper/imper-lecture-5/">Élettartam</a>). A globális 
és lokális statikus változók élettartama a program elejétől a végéig tart. 
A nem statikus lokálisak a veremben jönnek létre az őket deklaráló blokkba
való belépéskor és felszámolódnak, amikor kilépünk a blokkból. Lehetséges 
azonban, hogy ad-hc módon kell tárterületet foglalnunk, vagy előre nem ismerjük
a szükséges méretet. Ilyenkor használjuk a dinamikus élettartamot.</p>

<p>A dinamikus élettartamú objektumokat a <strong>szabad memóriában</strong> (free store, 
heap) foglaljuk le. Majdnem minden imperatív nyelv rendelkezik szabad 
memóriával, de annak használata erősen változó.</p>

<p>Java-ban, C#-ban objektumokat csak a szabad memóriában tudunk létrehozni a 
<strong>new</strong> segítségével. Ami lokális változó(nak) látszik, az is csak egy 
<em>referencia</em> (valójában egy pointer), maga az objektum a heap-ben jön létre.
A C nyelvben minden objektum (egyszerű vagy összetett típusú) létrejöhet
a statikus, az automatikus és a dinamikus tárterületen is.</p>

<p>A tárterület lefoglalása a <strong>malloc(size_t sz)</strong> függvénnyel történik, melynek 
a lefoglalandó bájtok számát adjuk meg. Hasznos, ha a paramétert a <strong>sizeof</strong>
operátoron keresztül adjuk meg, nem pedig “beégetjük” a programba. 
A visszatérő érték típusa <strong>void *</strong>, amit a kívánt típusra mutató pointerré 
kell konvertálnunk. A malloc garantálja, hogy a lefoglalt tárterületen 
tetszőleges típusú objektum tárolható. Viszont a tárterület nem lesz 
inicializálva, lényegében “memória-szemetet” fog tartalmazni. Ha a 
tárterületet csupa nulla bitre szeretnénk inicializálni, a <strong>calloc(size_t num,
size_t sz)</strong> függvényt használjuk, ami <em>num</em> darab <em>sz</em> méretű
objektumnak foglal helyet és a területet nullára inicializálja.</p>

<p>A tárterület lefoglalva marad, amíg azt a <strong>free(ptr)</strong> függvénnyel vissza 
nem adjuk a szabad memória számára. A <em>ptr</em> mindenképpen egy malloc(), 
calloc(), vagy <em>realloc()</em> függvény által adott kell legyen. Ha a tárterület
visszaadásáról megfeledkezünk, akkor <strong>elfogyhat a szabad memória</strong>. Ilyenkor 
amalloc(), calloc(), realloc() függvények NULL pointerat adnak vissza.
Mindig <strong>ellenőrizzük</strong> ezen függvények <strong>visszatérő értékét</strong>!</p>

<p>Ellentétben más programozási nyelvekkel, a C-ben (és C++-ban) <strong>nincsen 
automatikus szemétgyűjtés</strong> (garbage collection), azaz a már nem használt, 
akár már hivatkozás hiányában el sem érhető tárterületek sem szabadulnak fel
automatikusan. Ehhez <strong>mindig a free()</strong> függyvény <strong>meghívása</strong> kell. 
Azt a jelenséget, amikor az elérhetetlen tárterület a programozó hibájából
lefoglalva marad, nevezzük memória elszivárgásnak (memory leak). Hosszan 
futó programok esetében (pl. egy szerver program vagy maga az operációs 
rendszer) a memoriaelszivárgás súlyos gondokat okozhat.</p>

<p>A dinamikusan lefoglalt tárterületet a <strong>realloc(void *ptr, size_t newsize)</strong> 
függvénnyel tudjuk átméretezni. A <em>ptr</em> az egy előzőleg lefoglalt tárterület,
<em>newsize</em> pedig a kívánt új méret. A realloc() megpróbálja helyben megnövelni
a tárterületet, ha ez nem sikerül, akkor más helyen foglalja azt le, odamásolja
a régi terület tartalmát, majd felszabadítja azt. Ha nem sikerül az új
helyfoglalás, akkor NULL poinrter tér vissza és a régi terület megőrződik,
siker esetén az aktuális (akár új) területre mutató pointer tér vissza.
A realloc() elvileg alkalmas a lefoglalt terület csökkentésére is, azonban
implementáció függő, hogy valóban visszaad-e memóriát.</p>

<p>A realloc() veszélyes lehet, ha az átméretezendő tárterületünkre más mutatók 
hivatkoznak. Ilyenkor elmozgatva a hivatkozott tárterületet a mutatók 
érvénytelenné válnak.</p>

<h3 id="megjegyzsek">Megjegyzések</h3>

<ol>
  <li>
    <p>A szabad memória számon tartja, hogy mekkora területet foglaltunk le, ezt a
free()-nek nem kell megadnia. Az információ a heap-ben, a <em>ptr</em> környékén 
tárolódik, ha nem helyes pointerrel akarunk felszabadítani, az futási 
idejű hibát fog okozni.</p>
  </li>
  <li>
    <p>Vannak platformok, ahol a programban több heap is létezik, pl. a 
főprogramban és egyes dinamikus library-kben (.DLL, .so) is. Ilyenkor 
fontos, hogy ugyanaz a programrész szabadítsa fel a memóriát, aki 
lefoglalta, különben esetleg a <em>free</em> függvény rossz heap-be próbálná 
visszaadni a tárterületet. Ez futási idejű hibához vezethet.</p>
  </li>
  <li>
    <p>Úgy is elfogyhat a memória, ha a különböző méretű lefoglalások és 
felszabadítások során <strong>feldarabolódik</strong> a heap. Ilyenkor lenne még elég 
szabad bájt, csak nincsen elég egyetlen összefüggő területen. A mai
modern szabad memória implementációk számos módon próbálják ennek a 
lehetőségét csökkenteni. Érdekes megoldás a <em>.NET</em> framework-é, ott a
<em>managed</em> heap feltömöríti a használt területet, így eltüntetve a lyukakat,
egy összefüggő memóriaterületet hoz létre a szabad területből. Ilyenkor
azonban az átmozgatott területre mutató pointerek értékeit is módosítani
kell, ami komoly hatékonyságcsökkentő tevékenység.</p>
  </li>
  <li>
    <p>Ha egy területet felszabadítottunk, akkor tilos ismételten felszabadítani.
Ilyen hibát akkor szoktunk kapni, ha egy pointert lemásolunk és mindkét
helyen fel akarjuk szabadítani a mutatott tárterületet. Ez gyakran az ún.
<strong>sekély másolás</strong> (shallow copy) eredménye, amikor a pointert másoljuk a
mutatott tárterület helyett.</p>
  </li>
  <li>
    <p>A felszabadított memóriára tilos hivatkozni. Az <strong>indirekció</strong> (*) operátor
használata ilyenkor futási idejű hibát okozhat.</p>
  </li>
  <li>
    <p>A <em>free()</em> függvénynek átadhatunk <strong>NULL</strong> pointert, ilyenkor a hatása
az üres utasítással ekvivalens. A free() viszont nem állítja NULL-ra az 
átadott pointer értékét.</p>
  </li>
  <li>
    <p>A heap műveletek <em>szálbiztosak</em>, azaz többszálú programban is biztonsággal
használhatjuk őket. Viszont ez azt jelenti, hogy a heap használata a 
háttérben lock-olásokkal jár, ami csökkenti a hatékonyságot.</p>
  </li>
  <li>
    <p>Gyakori hiba, hogy egy C string másolása számára akarunk helyet foglalni 
az <em>strlen</em> függvény visszatérő értéke alapján. Azonban ha pont annyi 
helyet foglalunk le, akkor nem marad hely a lezáró bináris NUL karakterre.
Ezt a hibát hívják <strong>off by one</strong> (OBOE, OB1) errornak. Helyesen használjuk 
a <strong>malloc(strlen(source)+1)</strong> kifejezést.</p>
  </li>
  <li>
    <p>A dinamikus élettartammal kapcsolatos függvények az <strong>&lt;stdlib.h&gt;</strong> 
headerben vannak deklarálva.</p>
  </li>
</ol>

<h2 id="egy-plda-sszetett-adatszerkezetek-dinamikus-kezelsre">Egy példa összetett adatszerkezetek dinamikus kezelésére</h2>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno">  1</span> <span class="cp">#include &lt;stdio.h&gt;</span>
<span class="lineno">  2</span> <span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="lineno">  3</span> 
<span class="lineno">  4</span> <span class="k">struct</span> <span class="n">square</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">centerX</span><span class="p">;</span> <span class="kt">int</span> <span class="n">centerY</span><span class="p">;</span> <span class="kt">int</span> <span class="n">side</span><span class="p">;</span> <span class="p">};</span>
<span class="lineno">  5</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">centerX</span><span class="p">;</span> <span class="kt">int</span> <span class="n">centerY</span><span class="p">;</span> <span class="kt">int</span> <span class="n">lenA</span><span class="p">;</span> <span class="kt">int</span> <span class="n">lenB</span><span class="p">;</span> <span class="p">};</span>
<span class="lineno">  6</span> <span class="k">struct</span> <span class="n">circle</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">centerX</span><span class="p">;</span> <span class="kt">int</span> <span class="n">centerY</span><span class="p">;</span> <span class="kt">int</span> <span class="n">radius</span><span class="p">;</span> <span class="p">};</span>
<span class="lineno">  7</span> 
<span class="lineno">  8</span> <span class="k">typedef</span> <span class="k">struct</span> <span class="n">square</span>    <span class="kt">square_t</span><span class="p">;</span>
<span class="lineno">  9</span> <span class="k">typedef</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="kt">rectangle_t</span><span class="p">;</span>
<span class="lineno"> 10</span> <span class="k">typedef</span> <span class="k">struct</span> <span class="n">circle</span>    <span class="kt">circle_t</span><span class="p">;</span>
<span class="lineno"> 11</span> 
<span class="lineno"> 12</span> <span class="k">enum</span> <span class="kt">shape_tag_t</span> <span class="p">{</span> <span class="n">square_tag</span><span class="p">,</span> <span class="n">rectangle_tag</span><span class="p">,</span> <span class="n">circle_tag</span> <span class="p">};</span>
<span class="lineno"> 13</span> 
<span class="lineno"> 14</span> <span class="k">typedef</span>
<span class="lineno"> 15</span> <span class="k">struct</span> <span class="n">shape</span> <span class="cm">/* a shape on canvas */</span>
<span class="lineno"> 16</span> <span class="p">{</span>
<span class="lineno"> 17</span>   <span class="kt">int</span>               <span class="n">id</span><span class="p">;</span>
<span class="lineno"> 18</span>   <span class="k">enum</span> <span class="kt">shape_tag_t</span> <span class="n">tag</span><span class="p">;</span>
<span class="lineno"> 19</span>   <span class="k">union</span> <span class="n">shapeKind</span>
<span class="lineno"> 20</span>   <span class="p">{</span>
<span class="lineno"> 21</span>     <span class="kt">square_t</span>    <span class="n">s</span><span class="p">;</span>
<span class="lineno"> 22</span>     <span class="kt">rectangle_t</span> <span class="n">r</span><span class="p">;</span>
<span class="lineno"> 23</span>     <span class="kt">circle_t</span>    <span class="n">c</span><span class="p">;</span>
<span class="lineno"> 24</span>   <span class="p">}</span>   <span class="n">u</span><span class="p">;</span>
<span class="lineno"> 25</span> <span class="p">}</span> <span class="kt">shape_t</span><span class="p">;</span>
<span class="lineno"> 26</span> 
<span class="lineno"> 27</span> <span class="k">typedef</span>
<span class="lineno"> 28</span> <span class="k">struct</span> <span class="n">elem</span>  <span class="cm">/* one node in object ist */</span>
<span class="lineno"> 29</span> <span class="p">{</span>
<span class="lineno"> 30</span>   <span class="kt">shape_t</span>     <span class="o">*</span><span class="n">shp</span><span class="p">;</span>
<span class="lineno"> 31</span>   <span class="k">struct</span> <span class="n">elem</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="lineno"> 32</span> <span class="p">}</span> <span class="kt">elem_t</span><span class="p">;</span>
<span class="lineno"> 33</span> 
<span class="lineno"> 34</span> <span class="k">typedef</span>
<span class="lineno"> 35</span> <span class="k">struct</span> <span class="n">canvas</span>  <span class="cm">/* the canvas for shapes */</span>
<span class="lineno"> 36</span> <span class="p">{</span>
<span class="lineno"> 37</span>   <span class="kt">int</span>     <span class="n">count</span><span class="p">;</span>
<span class="lineno"> 38</span>   <span class="kt">elem_t</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
<span class="lineno"> 39</span> <span class="p">}</span> <span class="kt">canvas_t</span><span class="p">;</span>
<span class="lineno"> 40</span> 
<span class="lineno"> 41</span> <span class="kt">int</span> <span class="nf">genId</span><span class="p">()</span>
<span class="lineno"> 42</span> <span class="p">{</span>
<span class="lineno"> 43</span>   <span class="k">static</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 44</span>   <span class="k">return</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="lineno"> 45</span> <span class="p">}</span>
<span class="lineno"> 46</span> 
<span class="lineno"> 47</span> <span class="kt">shape_t</span> <span class="o">*</span><span class="nf">createSquare</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">side</span><span class="p">)</span>
<span class="lineno"> 48</span> <span class="p">{</span>
<span class="lineno"> 49</span>   <span class="kt">shape_t</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">shape_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">shape_t</span><span class="p">));</span>
<span class="lineno"> 50</span>   <span class="k">if</span> <span class="p">(</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">sp</span> <span class="p">)</span>
<span class="lineno"> 51</span>     <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="lineno"> 52</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span>        <span class="o">=</span> <span class="n">genId</span><span class="p">();</span>
<span class="lineno"> 53</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">tag</span>       <span class="o">=</span> <span class="n">square_tag</span><span class="p">;</span>
<span class="lineno"> 54</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">centerX</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> 
<span class="lineno"> 55</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">centerY</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> 
<span class="lineno"> 56</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">side</span>    <span class="o">=</span> <span class="n">side</span><span class="p">;</span>
<span class="lineno"> 57</span>   <span class="k">return</span> <span class="n">sp</span><span class="p">;</span> 
<span class="lineno"> 58</span> <span class="p">}</span>
<span class="lineno"> 59</span> 
<span class="lineno"> 60</span> <span class="kt">shape_t</span> <span class="o">*</span><span class="nf">createRectangle</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="lineno"> 61</span> <span class="p">{</span>
<span class="lineno"> 62</span>   <span class="kt">shape_t</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">shape_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">shape_t</span><span class="p">));</span>
<span class="lineno"> 63</span>   <span class="k">if</span> <span class="p">(</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">sp</span> <span class="p">)</span>
<span class="lineno"> 64</span>     <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="lineno"> 65</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span>        <span class="o">=</span> <span class="n">genId</span><span class="p">();</span>
<span class="lineno"> 66</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">tag</span>       <span class="o">=</span> <span class="n">rectangle_tag</span><span class="p">;</span>
<span class="lineno"> 67</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">centerX</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> 
<span class="lineno"> 68</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">centerY</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> 
<span class="lineno"> 69</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">lenA</span>    <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="lineno"> 70</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">lenB</span>    <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="lineno"> 71</span>   <span class="k">return</span> <span class="n">sp</span><span class="p">;</span> 
<span class="lineno"> 72</span> <span class="p">}</span>
<span class="lineno"> 73</span> 
<span class="lineno"> 74</span> <span class="kt">shape_t</span> <span class="o">*</span><span class="nf">createCircle</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="lineno"> 75</span> <span class="p">{</span>
<span class="lineno"> 76</span>   <span class="kt">shape_t</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">shape_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">shape_t</span><span class="p">));</span>
<span class="lineno"> 77</span>   <span class="k">if</span> <span class="p">(</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">sp</span> <span class="p">)</span>
<span class="lineno"> 78</span>     <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="lineno"> 79</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span>        <span class="o">=</span> <span class="n">genId</span><span class="p">();</span>
<span class="lineno"> 80</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">tag</span>       <span class="o">=</span> <span class="n">circle_tag</span><span class="p">;</span>
<span class="lineno"> 81</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">centerX</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> 
<span class="lineno"> 82</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">centerY</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> 
<span class="lineno"> 83</span>   <span class="n">sp</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">radius</span>  <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
<span class="lineno"> 84</span>   <span class="k">return</span> <span class="n">sp</span><span class="p">;</span> 
<span class="lineno"> 85</span> <span class="p">}</span>
<span class="lineno"> 86</span> 
<span class="lineno"> 87</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sShapeKind</span><span class="p">(</span><span class="k">enum</span> <span class="kt">shape_tag_t</span> <span class="n">tg</span><span class="p">)</span>
<span class="lineno"> 88</span> <span class="p">{</span>
<span class="lineno"> 89</span>   <span class="k">switch</span><span class="p">(</span> <span class="n">tg</span> <span class="p">)</span>
<span class="lineno"> 90</span>   <span class="p">{</span>
<span class="lineno"> 91</span>   <span class="k">case</span>    <span class="nl">square_tag</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;square&quot;</span><span class="p">;</span>
<span class="lineno"> 92</span>   <span class="k">case</span> <span class="nl">rectangle_tag</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;rectangle&quot;</span><span class="p">;</span> 
<span class="lineno"> 93</span>   <span class="k">case</span>    <span class="nl">circle_tag</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;circle&quot;</span><span class="p">;</span>
<span class="lineno"> 94</span>   <span class="k">default</span>           <span class="o">:</span> <span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
<span class="lineno"> 95</span>   <span class="p">}</span>
<span class="lineno"> 96</span> <span class="p">}</span>
<span class="lineno"> 97</span>  
<span class="lineno"> 98</span> <span class="kt">void</span> <span class="nf">printShape</span><span class="p">(</span><span class="kt">shape_t</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="lineno"> 99</span> <span class="p">{</span>
<span class="lineno">100</span>   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;id = %d, type = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">sShapeKind</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">));</span>
<span class="lineno">101</span> <span class="p">}</span>
<span class="lineno">102</span> 
<span class="lineno">103</span> <span class="kt">void</span> <span class="nf">initCanvas</span><span class="p">(</span> <span class="kt">canvas_t</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="lineno">104</span> <span class="p">{</span>
<span class="lineno">105</span>   <span class="n">cp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">106</span>   <span class="n">cp</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="lineno">107</span> <span class="p">}</span>
<span class="lineno">108</span> 
<span class="lineno">109</span> <span class="kt">void</span> <span class="nf">addCanvas</span><span class="p">(</span> <span class="kt">canvas_t</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">shape_t</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="lineno">110</span> <span class="p">{</span>
<span class="lineno">111</span>   <span class="kt">elem_t</span> <span class="o">*</span><span class="n">newElem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">elem_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">elem_t</span><span class="p">));</span>
<span class="lineno">112</span>   <span class="n">newElem</span><span class="o">-&gt;</span><span class="n">shp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span> 
<span class="lineno">113</span>   <span class="n">newElem</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="lineno">114</span>   <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="p">)</span>
<span class="lineno">115</span>     <span class="n">cp</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">=</span> <span class="n">newElem</span><span class="p">;</span> 
<span class="lineno">116</span>   <span class="k">else</span>
<span class="lineno">117</span>   <span class="p">{</span>
<span class="lineno">118</span>     <span class="kt">elem_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="lineno">119</span>     <span class="k">while</span> <span class="p">(</span> <span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="p">)</span>
<span class="lineno">120</span>       <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="lineno">121</span>     <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newElem</span><span class="p">;</span>
<span class="lineno">122</span>   <span class="p">}</span>
<span class="lineno">123</span>   <span class="o">++</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="lineno">124</span> <span class="p">}</span>
<span class="lineno">125</span> <span class="kt">void</span> <span class="nf">deleteCanvas</span><span class="p">(</span> <span class="kt">canvas_t</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="lineno">126</span> <span class="p">{</span>
<span class="lineno">127</span>   <span class="kt">elem_t</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="lineno">128</span>   <span class="k">while</span> <span class="p">(</span> <span class="nb">NULL</span> <span class="o">!=</span> <span class="n">ep</span> <span class="p">)</span>
<span class="lineno">129</span>   <span class="p">{</span>
<span class="lineno">130</span>     <span class="kt">elem_t</span> <span class="o">*</span><span class="n">ptrToDel</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
<span class="lineno">131</span>     <span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="lineno">132</span> 
<span class="lineno">133</span>     <span class="n">free</span><span class="p">(</span> <span class="n">ptrToDel</span><span class="o">-&gt;</span><span class="n">shp</span><span class="p">);</span>
<span class="lineno">134</span>     <span class="n">free</span><span class="p">(</span> <span class="n">ptrToDel</span><span class="p">);</span> 
<span class="lineno">135</span>   <span class="p">}</span>
<span class="lineno">136</span> <span class="p">}</span>
<span class="lineno">137</span> 
<span class="lineno">138</span> <span class="kt">void</span> <span class="nf">printCanvas</span><span class="p">(</span> <span class="kt">canvas_t</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="lineno">139</span> <span class="p">{</span>
<span class="lineno">140</span>   <span class="kt">elem_t</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="lineno">141</span>   <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;num of shapes = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="lineno">142</span>   
<span class="lineno">143</span>   <span class="k">while</span> <span class="p">(</span> <span class="nb">NULL</span> <span class="o">!=</span> <span class="n">ep</span> <span class="p">)</span>
<span class="lineno">144</span>   <span class="p">{</span>
<span class="lineno">145</span>     <span class="n">printShape</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">shp</span><span class="p">);</span>
<span class="lineno">146</span>     <span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="lineno">147</span>   <span class="p">}</span>
<span class="lineno">148</span> <span class="p">}</span>
<span class="lineno">149</span> 
<span class="lineno">150</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="lineno">151</span> <span class="p">{</span>
<span class="lineno">152</span>   <span class="kt">canvas_t</span> <span class="n">cvs</span><span class="p">;</span>
<span class="lineno">153</span> 
<span class="lineno">154</span>   <span class="n">initCanvas</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">cvs</span><span class="p">);</span>
<span class="lineno">155</span> 
<span class="lineno">156</span>   <span class="n">addCanvas</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">cvs</span><span class="p">,</span> <span class="n">createCircle</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
<span class="lineno">157</span>   <span class="n">addCanvas</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">cvs</span><span class="p">,</span> <span class="n">createRectangle</span><span class="p">(</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">));</span> 
<span class="lineno">158</span> 
<span class="lineno">159</span>   <span class="n">printCanvas</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">cvs</span><span class="p">);</span>
<span class="lineno">160</span>   <span class="n">deleteCanvas</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">cvs</span><span class="p">);</span>
<span class="lineno">161</span> 
<span class="lineno">162</span>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">163</span> <span class="p">}</span></code></pre></div>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./a.out 
num of <span class="nv">shapes</span> <span class="o">=</span> 2
<span class="nv">id</span> <span class="o">=</span> 0, <span class="nb">type</span> <span class="o">=</span> circle
<span class="nv">id</span> <span class="o">=</span> 1, <span class="nb">type</span> <span class="o">=</span> rectangle</code></pre></div>

<p>A program futását ellenőrizhetjük valamely dinamikus analízis eszközzel, pl.
a <strong>google memory sanitizer</strong>-rel vagy a <strong>valgrind</strong>-al.</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">valgrind ./a.out
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> Memcheck, a memory error <span class="nv">detector</span>
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> Copyright <span class="o">(</span>C<span class="o">)</span> 2002-2013, and GNU GPL<span class="err">&#39;</span>d, by Julian Seward et al.
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> Using Valgrind-3.10.1 and LibVEX<span class="p">;</span> rerun with -h <span class="k">for</span> copyright <span class="nv">info</span>
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> Command: ./a.out
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> 
num of <span class="nv">shapes</span> <span class="o">=</span> 2
<span class="nv">id</span> <span class="o">=</span> 0, <span class="nb">type</span> <span class="o">=</span> circle
<span class="nv">id</span> <span class="o">=</span> 1, <span class="nb">type</span> <span class="o">=</span> <span class="nv">rectangle</span>
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> 
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> HEAP SUMMARY:
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span>     in use at <span class="nb">exit</span>: <span class="m">0</span> bytes in <span class="m">0</span> <span class="nv">blocks</span>
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span>   total heap usage: <span class="m">4</span> allocs, <span class="m">4</span> frees, <span class="m">80</span> bytes <span class="nv">allocated</span>
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> 
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> All heap blocks were freed -- no leaks are <span class="nv">possible</span>
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> 
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> For counts of detected and suppressed errors, rerun with: -v
<span class="o">==</span><span class="nv">30117</span><span class="o">==</span> ERROR SUMMARY: <span class="m">0</span> errors from <span class="m">0</span> contexts <span class="o">(</span>suppressed: <span class="m">0</span> from 0<span class="o">)</span></code></pre></div>


  </article>

</div>

  </article>

</div>

      </div>

       <div id='footer'>Copyright &copy; 2015-2017 Zoltán Porkoláb</div>




    </div>
  </body>

   <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73707766-1', 'auto');
  ga('send', 'pageview');

</script>


</html>
