Az eddigi pédákban szereplő műveletek (operation és option együtt)

Részletesebb információk az alábbi dokumentációkban találhatók:

Oracle Documentation: 11g release 2
Performance Tuning Guide, chapter 11 és 12

Oracle Documentation 12c
Database SQL Tuning Guide

Hintekről 
SQL Language Reference -> 3. Basic Elements of Oracle SQL -> Comments -> Hints


TABLE ACCESS FULL
             HASH          -- hash clusteren levő táblák elérése a hash függvény alapján
             CLUSTER       -- index clusteren levő táblák elérése
             BY INDEX ROWID
             BY USER ROWID
             BY GLOBAL INDEX ROWID
             BY LOCAL INDEX ROWID

PARTITION RANGE ALL        -- összes partíció olvasása
PARTITION RANGE SINGLE     -- egyetlen partíció olvasása
PARTITION RANGE ITERATOR   -- több partíció olvasása
INLIST ITERATOR            -- műveletek ismétlése

SORT AGGREGATE             -- ha csak egy sor lesz a csoportosítás végén
     UNIQUE                -- ismétlődések megszüntetéséhez
     GROUP BY              -- ha több csoport lesz
     JOIN                  -- előrendezés a join-hoz
     ORDER BY

HASH UNIQUE
HASH GROUP BY

UNION-ALL
MINUS
CONCATENATION              -- unió képzése két sorhalmazból
VIEW
FILTER                     -- egy sorhalmaz szűrése

NESTED LOOPS               -- join művelet
MERGE JOIN                 -- rendezett részek összefuttatása
HASH JOIN
HASH JOIN OUTER
HASH JOIN ANTI             -- not exist-hez lehet jó
HASH JOIN SEMI             -- ha a join után csak az egyik tábla adatai kellenek

INDEX FULL SCAN            -- teljes index végigolvasása növekvő sorrendben
INDEX FULL SCAN DESCENDING -- teljes index végigolvasása csökkenő sorrendben
INDEX FAST FULL SCAN       -- teljes index végigolvasása, egyszerre több blokkot olvasva
INDEX RANGE SCAN           -- intervallum keresés növekvő sorrendben (DESCENDING -> csökkenő)
INDEX UNIQUE SCAN          -- egyedi érték keresés
INDEX SKIP SCAN            -- több oszlopos index olvasása, az első oszlopok ismerete nélkül

AND-EQUAL                  -- sorazonosító halmazok metszetét képezi

BITMAP INDEX SINGLE VALUE      -- egyetlen bitvektor visszaadása
BITMAP AND                     -- bitmapek közötti logikai művelet
BITMAP OR                      -- bitmapek közötti logikai művelet
BITMAP CONVERSION TO ROWIDS    -- bitmap átalakítása sorazonosítóvá
BITMAP CONVERSION FROM ROWIDS  -- sorazonosító átalakítása bitmappé
BITMAP CONVERSION COUNT        -- ha csak a sorazonosítók számára van szükség

INLIST ITERATOR            -- műveletek ciklusban


Tippek (hint) adása az optimalizálónak

Mindig csak arra az utasitás blokkra vonatkoznak, amiben szerepelnek. 
Az utasitás blokk a következők egyike lehet:
- Egyszerű SELECT, UPDATE, DELETE INSERT utasitas
- Komplex utasitásban a subquery, vagy a kulső utasitás (pl. INSERT ... SELECT ...)
- Összetett utasitás egyik része (pl. SELECT ... UNION SELECT ... esetén)
A tipp csak közvetlenül az utasitás kulcsszava után jöhet megjegyzésben.
[SELECT|DELETE|UPDATE|INSERT]   /*+  tipp lista  */    (a '+' előtt nincs szoköz !!! )
Ha hiba van a hint-ben az oracle figyelmen kívül hagyja de nem jelez hibát.

Példák:
SELECT /*+ tipp lista */  * FROM emp WHERE ...
SELECT /*+ tipp lista */  * FROM emp WHERE deptno IN ( SELECT /*+ tipp lista */  deptno FROM ...)
INSERT /*+ tipp lista */  ... SELECT /*+ tipp lista */  ...
SELECT /*+ tipp lista */  ...  UNION  SELECT /*+ tipp lista */  ...

Fontos! Ha minősített tábla szerepel a lekérdezésben akkor használjunk aliast, pl.
  SELECT /*+ full(c) */ ... FROM nikovits.cikk c ...



A legfontosabb tippek: (a teljes lista -> SQL Reference) 

ALL_ROWS
Költseg alapú optimalizalast valaszt es azon belul is a teljes lekerdezesre optimalizal.

FIRST_ROWS(n)  
A legjobb valaszidőre optimalizál. Az lekérdezés első n sorát a lehető leggyorsabban
próbálja meg visszaadni. Ha nem adjuk meg n-et, akkor n=1-et tekinti.

FULL(tabla)   vagy  FULL(aliasnev)
Nem hasznal indexet, hanem full table scant.

CLUSTER(tabla)
Csak index clusteren lévő tábláknál van értelme. 

HASH(tabla)
Csak hash clusteren lévő táblánál van értelme.


INDEX(tabla  [indexlista])
A tablat index alapjan eri el. Ha nem adunk meg index nevet (vagy többet adunk meg) 
akkor a legolcsóbb költségű indexet (a felsoroltakbol) használja.

INDEX_ASC(tabla  [indexlista])
Növekvő sorrendben eri el az index bejegyzeseket.

INDEX_DESC(tabla  [indexlista])
Megfordítja az alapértelmezett index bejárási sorrendet. Csökkenő sorrendben éri el 
az index bejegyzéseket. (Illetve csökkenő indexnél növekvőben.)

INDEX_COMBINE(tabla  [indexlista])
Bitmap indexek segítségével próbálja meg elérni az adatokat.

INDEX_FFS(tabla  [indexlista])
Fast full index scan-re utasítja az optimalizálót a teljes tábla olvasás helyett.

INDEX_JOIN(tabla  [indexlista])
Több index használatával és a sorazonosítók join-olásával érje el a táblát.

AND_EQUAL(tabla  [indexlista])
Több index egyidejű használatával éri el a táblát. A sorazonosítók metszetét képezi.

NO_INDEX(tabla  [indexlista])
A megadott indexek használatáról lebeszéli az optimalizálót.

NO_INDEX_FFS(tabla  [indexlista])
A megadott indexek használatáról lebeszéli az optimalizálót.

NO_EXPAND
Ha a lekérdezésben OR vagy IN szerepel, akkor az optimalizáló hajlamos az egyes
esetek szerint külön-külön keresni (pl. index használatával). Ez a hint erről 
beszéli le az optimalizálót.

USE_CONCAT
Az OR feltételekből uniót hoz létre, és így hajtja végre a lekérdezést.

LEADING(táblalista)
A megadott táblákkal kezdi a lekérdezés végrehajtását. (Hasonló az ORDERED-hez)

ORDERED
A táblákat abban a sorrendben fogja join-olni, ahogy azok a FROM után megjelennek.

USE_HASH(táblalista)
A megadott tablakat hash join-nal join-olja a többi adatforrashoz. 
NO_USE_HASH(táblalista)
Az előző ellentéte.

USE_NL(táblalista)
A megadott tablakat nested looppal join-olja a többi adatforrashoz. A megadott tabla 
lesz a belső ciklus tablaja.
NO_USE_NL(táblalista)
Az előző ellentéte

USE_MERGE(táblalista)
A megadott tablakat sort-merge-el join-olja a többi adatforrashoz.
NO_USE_MERGE(tablalista) 
Az előző ellentéte.

NL_SJ, HASH_SJ, MERGE_SJ
NL_AJ, HASH_AJ, MERGE_AJ
A fentieket az alkérdésben lehet hintként megadni, és ekkor (ha lehetséges)
az oracle a megfelelő algoritmussal fogja a semi-joint, illetve anti-joint
elvégezni.

CURSOR_SHARING_EXACT
Arra utasítja az oracle-t, hogy semmiképpen ne cserélje le az utasítás elemzése 
közben a literálokat bind változóra. Amúgy ezt lehet, hogy megtenné mivel ezzel
csökkenne az újraelemzések esélye. (lásd -> CURSOR_SHARING init paraméter)

DRIVING_SITE(tabla)
Elosztott lekérdezésnél van értelme. Arra utasítja az optimalizálót, hogy a megadott 
tábla adatbázisában hajtsa végre a műveletet. (pl. join esetén távoli táblák között)

DYNAMIC_SAMPLING(tabla n) ahol 0 <= n <= 10
Menet közben próbál meg minta alapján döntéseket hozni a szelektivitásra vonatkozóan.
Minél nagyobb az n értéke, annál nagyobb mintát használ.

CACHE(tabla)
Hatasara a tabla blokkjai a buffer cache LRU listajanak "friss" vegere kerulnek. 
Kis tablaknal hasznos, hogy sokaig csücsülhessenek a bufferben.

NOCACHE(tabla)
Hatasara a tabla blokkjai a buffer cache LRU listajanak "régi" vegere kerulnek. 
Alapertelmezes szerint is ide kerulnenek.

APPEND
INSERT utasításban az utolsó blokk utáni területre teszi be az adatokat, és nem a blokkokban
meglévő szabad helyekre. Ezáltal gyorsabb lesz, de pazarlóbb.

NOAPPEND
A blokkok meglévő üres helyeit is kihasználja. (Illetve letiltja a párhuzamos insert-et)

MERGE(V)
V egy nézet neve. A nézet kiértékelésének egyik módja a nézet merge-elése a 
fő lekérdezésbe. Erre utasítja az optimalizálót. Inline nézet esetén a hintet
beírhatjuk a nézet blokkjába (paraméter nélkül), vagy a fő lekérdezésbe (paraméterrel).

NO_MERGE(V)
Az előző ellentétére veszi rá az optimalizálót.

NO_QUERY_TRANSFORMATION
Az optimalizáló képes arra, hogy a lekérdezést valamilyen módon átalakítsa, és azt
hajtsa végre. Ilyen átalakítás például az OR-expansion, View-merging, Subquery-unnest,
Star-transformation, Materialized view-rewrite. A hint ezekről beszéli le az optimalizálót.
A fenti átalakítások mindegyike külön-külön is kérhető illetve letiltható egy hinttel.
USE_CONCAT - NO_EXPAND, MERGE - NO_MERGE, UNNEST - NO_UNNEST, 
STAR_TRANSFORMATION - NO_STAR_TRANSFORMATION, REWRITE - NO_REWRITE

RULE
Szabály alapú optimalizálást használ, de ez a hint már nem javasolt.


